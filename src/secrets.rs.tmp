use std::collections::HashMap;
use std::sync::Arc;

use anyhow::{anyhow, Context, Result};
use once_cell::sync::Lazy;
use regex::Regex;
use reqwest::Client;
use serde::Deserialize;
use serde_json::Value;
use tokio::sync::RwLock;

use crate::config::{SecretBackend, SecretsConfig};

static SECRET_REF_PATTERN: Lazy<Regex> =
    Lazy::new(|| Regex::new(r"^(?P<backend>[a-z]+)://(?P<path>[^#]+)#(?P<key>.+)$").unwrap());

#[derive(Clone)]
pub struct SecretManager {
    backend: SecretBackend,
    client: Client,
    cache: Arc<RwLock<HashMap<String, String>>>,
}

impl SecretManager {
    pub fn new(config: &SecretsConfig) -> Result<Self> {
        Ok(Self {
            backend: config.backend.clone(),
            client: Client::builder()
                .use_rustls_tls()
                .build()
                .context("building secret manager HTTP client")?,
            cache: Arc::new(RwLock::new(HashMap::new())),
        })
    }

    pub async fn resolve(&self, reference: &SecretReference) -> Result<String> {
        let cache_key = reference.cache_key();
        if let Some(value) = self.cache.read().await.get(&cache_key).cloned() {
            return Ok(value);
        }

        let resolved = match (&self.backend, reference.kind) {
            (SecretBackend::None, _) => {
                return Err(anyhow!(
                    "secret backend is not configured (needed for `{}`)",
                    reference.path
                ))
            }
            (SecretBackend::Vault(config), SecretBackendKind::Vault) => {
                self.fetch_vault_secret(config, reference).await?
            }
            _ => {
                return Err(anyhow!(
                    "secret backend mismatch for reference `{}`",
                    reference.path
                ))
            }
        };

        self.cache
            .write()
            .await
            .insert(cache_key.clone(), resolved.clone());
        Ok(resolved)
    }

    async fn fetch_vault_secret(
        &self,
        config: &crate::config::VaultConfig,
        reference: &SecretReference,
    ) -> Result<String> {
        let url = format!(
            "{}/v1/{}",
            config.addr.trim_end_matches('/'),
            reference.path.trim_start_matches('/')
        );
        let mut request = self.client.get(url);
        request = request.header("X-Vault-Token", &config.token);
        if let Some(ns) = &config.namespace {
            request = request.header("X-Vault-Namespace", ns);
        }
        let response = request.send().await.context("vault request failed")?;
        if !response.status().is_success() {
            return Err(anyhow!(
                "vault responded with status {} for {}",
                response.status(),
                reference.path
            ));
        }
        let payload: VaultResponse = response
            .json()
            .await
            .context("failed to decode vault response")?;
        payload.get(&reference.key).ok_or_else(|| {
            anyhow!(
                "vault secret `{}` missing key `{}`",
                reference.path,
                reference.key
            )
        })
    }
}

pub fn parse_secret_reference(raw: &str) -> Result<Option<SecretReference>> {
    if let Some(captures) = SECRET_REF_PATTERN.captures(raw) {
        let backend = captures
            .name("backend")
            .map(|m| m.as_str())
            .unwrap_or_default();
        let path = captures
            .name("path")
            .map(|m| m.as_str().to_string())
            .ok_or_else(|| anyhow!("missing secret path"))?;
        let key = captures
            .name("key")
            .map(|m| m.as_str().to_string())
            .ok_or_else(|| anyhow!("missing secret key"))?;
        let kind = match backend {
            "vault" => SecretBackendKind::Vault,
            other => {
                return Err(anyhow!(
                    "unsupported secret backend `{other}` in value `{raw}`"
                ))
            }
        };
        return Ok(Some(SecretReference { kind, path, key }));
    }
    Ok(None)
}

#[derive(Clone)]
pub struct SecretReference {
    kind: SecretBackendKind,
    path: String,
    key: String,
}

impl SecretReference {
    fn cache_key(&self) -> String {
        format!("{}#{}", self.path, self.key)
    }
}

#[derive(Clone, Copy)]
enum SecretBackendKind {
    Vault,
}

#[derive(Debug, Deserialize)]
struct VaultResponse {
    data: VaultData,
}

#[derive(Debug, Deserialize)]
#[serde(untagged)]
enum VaultData {
    V1(HashMap<String, String>),
    V2 {
        data: HashMap<String, String>,
        #[serde(default)]
        _metadata: Value,
    },
}

impl VaultResponse {
    fn get(&self, key: &str) -> Option<String> {
        match &self.data {
            VaultData::V1(map) => map.get(key).cloned(),
            VaultData::V2 { data } => data.get(key).cloned(),
        }
    }
}
