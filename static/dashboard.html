<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Open RPC Load Balancer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              midnight: "#090d1a",
              aurora: "#6366f1",
              auroraLight: "#a855f7",
              success: "#34d399",
              warning: "#fb923c",
            },
          },
        },
      };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
  </head>
  <body class="bg-slate-950 text-slate-100 min-h-screen antialiased">
    <div
      class="pointer-events-none absolute inset-0 opacity-30"
      style="
        background:
          radial-gradient(circle at 15% 15%, rgba(99, 102, 241, 0.35), transparent 55%),
          radial-gradient(circle at 85% 20%, rgba(168, 85, 247, 0.25), transparent 55%),
          radial-gradient(circle at 50% 80%, rgba(14, 165, 233, 0.18), transparent 60%);
      "
    ></div>
    <div class="relative z-10 mx-auto max-w-6xl space-y-8 px-6 py-10">
      <div
        id="errorBanner"
        class="hidden rounded-2xl border border-red-400/30 bg-red-500/10 px-5 py-3 text-sm text-red-200 shadow-lg shadow-red-900/30"
        role="alert"
      ></div>

      <header class="rounded-3xl border border-white/10 bg-white/5 px-8 py-10 shadow-2xl shadow-aurora/5 backdrop-blur">
        <div class="flex flex-col gap-8 lg:flex-row lg:items-start lg:justify-between">
          <div class="space-y-5">
            <div class="flex items-center gap-4">
              <img src="/aurflow.png" alt="AurFlow logo" class="h-12 w-12 rounded-full border border-white/20 bg-white/80" />
              <div>
                <p class="text-xs uppercase tracking-[0.35em] text-slate-400">Open RPC Load Balancer</p>
                <h1 class="text-3xl font-semibold leading-tight text-white md:text-4xl">Provider Control Room</h1>
              </div>
            </div>
            <p class="max-w-3xl text-sm leading-relaxed text-slate-300">
              Track routing health, slot freshness, and weighted scores in real time. Refresh manually or let AurFlow stream new snapshots every few seconds while you keep an eye on upcoming hedges, quarantines, and weight overrides.
            </p>
            <div class="flex flex-wrap gap-2 text-[0.65rem] uppercase tracking-[0.4em] text-slate-400">
              <span class="rounded-full border border-white/10 px-3 py-1">Live snapshot</span>
              <span class="rounded-full border border-white/10 px-3 py-1">Latency &amp; score</span>
              <span class="rounded-full border border-white/10 px-3 py-1">Slot health</span>
            </div>
          </div>
          <div class="w-full max-w-sm rounded-2xl border border-white/10 bg-slate-950/60 p-5 shadow-inner shadow-black/40">
            <p class="text-xs uppercase tracking-[0.4em] text-slate-500">Controls</p>
            <button
              id="refreshButton"
              type="button"
              class="mt-3 inline-flex w-full items-center justify-center gap-3 rounded-2xl bg-aurora px-5 py-2.5 text-sm font-semibold text-white shadow-lg shadow-aurora/30 transition hover:-translate-y-0.5 hover:bg-auroraLight focus:outline-none focus-visible:ring-2 focus-visible:ring-aurora/60"
            >
              <span class="inline-flex h-2 w-2 items-center justify-center rounded-full bg-white/80 shadow-inner shadow-white/60"></span>
              <span>Refresh snapshot</span>
            </button>
            <p class="mt-4 text-xs text-slate-400">Snapshots auto-refresh every five seconds when Auto is enabled.</p>
            <div class="mt-4 flex items-center justify-between gap-3 text-xs text-slate-300">
              <label
                for="autoRefreshToggle"
                class="inline-flex items-center gap-2 rounded-full border border-white/15 bg-slate-900/60 px-3 py-1.5 shadow-inner shadow-black/40"
              >
                <input
                  id="autoRefreshToggle"
                  type="checkbox"
                  class="h-4 w-4 rounded border-white/30 bg-slate-900/60 text-aurora focus:ring-aurora/60"
                  checked
                />
                <span class="font-semibold uppercase tracking-[0.3em] text-slate-300">Auto</span>
              </label>
              <span
                id="autoRefreshStatus"
                class="rounded-full border border-white/10 bg-white/5 px-3 py-1 text-xs font-semibold text-slate-200"
                aria-live="polite"
              >
                Next in 5s
              </span>
            </div>
          </div>
        </div>
      </header>

      <section aria-label="Snapshot metrics" class="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
        <article class="rounded-2xl border border-white/10 bg-slate-950/60 p-5 shadow-inner shadow-black/30">
          <p class="text-xs uppercase tracking-[0.35em] text-slate-400">Providers Online</p>
          <p class="mt-3 text-3xl font-semibold text-white" id="providerCount">--</p>
          <p class="mt-1 text-xs text-slate-400" id="healthyCount">--</p>
        </article>
        <article class="rounded-2xl border border-white/10 bg-slate-950/60 p-5 shadow-inner shadow-black/30">
          <p class="text-xs uppercase tracking-[0.35em] text-slate-400">Average Latency</p>
          <p class="mt-3 text-3xl font-semibold text-white" id="avgLatency">--</p>
          <p class="mt-1 text-xs text-slate-400" id="latencyDetail">--</p>
        </article>
        <article class="rounded-2xl border border-white/10 bg-slate-950/60 p-5 shadow-inner shadow-black/30">
          <p class="text-xs uppercase tracking-[0.35em] text-slate-400">Last Updated</p>
          <p class="mt-3 text-3xl font-semibold text-white" id="lastUpdated">--</p>
          <p class="mt-1 text-xs text-slate-400" id="updatedAgo">--</p>
        </article>
      </section>

      <section class="rounded-3xl border border-white/10 bg-white/5 px-6 py-8 backdrop-blur">
        <div class="flex flex-col gap-4 md:flex-row md:items-center md:justify-between">
          <div>
            <h2 class="text-xl font-semibold text-white">Latency &amp; Scoreboard</h2>
            <p class="text-sm text-slate-400">Compare providers side-by-side. Lower weighted scores represent healthier routing choices.</p>
          </div>
          <div
            id="metricToggle"
            class="inline-flex items-center gap-1 rounded-full border border-white/15 bg-slate-900/70 p-1 text-xs font-medium text-slate-300 shadow-inner shadow-black/40"
            role="group"
          >
            <button
              type="button"
              class="metric-toggle inline-flex items-center gap-2 rounded-full px-4 py-2 text-slate-300 transition focus:outline-none focus-visible:ring-2 focus-visible:ring-aurora/60"
              data-metric="latency"
            >
              Live Latency
            </button>
            <button
              type="button"
              class="metric-toggle inline-flex items-center gap-2 rounded-full px-4 py-2 text-slate-300 transition focus:outline-none focus-visible:ring-2 focus-visible:ring-aurora/60"
              data-metric="latency_ema"
            >
              EMA Latency
            </button>
            <button
              type="button"
              class="metric-toggle inline-flex items-center gap-2 rounded-full px-4 py-2 text-slate-300 transition focus:outline-none focus-visible:ring-2 focus-visible:ring-aurora/60"
              data-metric="score"
            >
              Weighted Score
            </button>
          </div>
        </div>
        <div class="mt-6 h-80 rounded-2xl border border-white/10 bg-slate-950/50 p-4">
          <canvas id="latencyChart"></canvas>
        </div>
      </section>

      <section class="space-y-4 pb-12">
        <div class="flex flex-col gap-2 md:flex-row md:items-baseline md:justify-between">
          <div>
            <h2 class="text-xl font-semibold text-white">Provider Deep Dive</h2>
            <p class="text-sm text-slate-400">Hover cards for detail. Metrics blend live routing stats, health probes, and commitment freshness.</p>
          </div>
          <p class="text-xs uppercase tracking-[0.35em] text-slate-400">Data refreshes every 5s</p>
        </div>
        <div
          id="providerCards"
          class="grid gap-6 sm:grid-cols-2 xl:grid-cols-3"
        ></div>
      </section>
    </div>
<template id="providerCardTemplate">
      <article class="group relative overflow-hidden rounded-3xl border border-white/10 bg-slate-950/70 p-6 shadow-lg shadow-black/40 transition duration-300 hover:border-aurora/40 hover:shadow-aurora/30">
        <div class="flex items-start justify-between gap-4">
          <div>
            <h3 class="text-lg font-semibold text-white"></h3>
            <p class="text-sm text-slate-400"></p>
          </div>
          <span class="flex items-center gap-2 rounded-full px-3 py-1 text-xs font-semibold">
            <span class="h-2 w-2 rounded-full"></span>
            <span></span>
          </span>
        </div>
        <dl class="mt-6 space-y-3 text-sm">
          <div class="flex items-center justify-between gap-3">
            <dt class="text-slate-400">Latency</dt>
            <dd class="font-medium text-white"></dd>
          </div>
          <div class="flex items-center justify-between gap-3">
            <dt class="text-slate-400">EMA (ms)</dt>
            <dd class="font-medium text-white"></dd>
          </div>
          <div class="flex items-center justify-between gap-3">
            <dt class="text-slate-400">Success / Errors</dt>
            <dd class="font-medium text-white"></dd>
          </div>
          <div class="flex items-center justify-between gap-3">
            <dt class="text-slate-400">Probe Pass / Fail</dt>
            <dd class="font-medium text-white"></dd>
          </div>
          <div class="flex items-center justify-between gap-3">
            <dt class="text-slate-400">Weighted Score</dt>
            <dd class="font-medium text-white"></dd>
          </div>
          <div class="flex items-center justify-between gap-3">
            <dt class="text-slate-400">Effective Weight</dt>
            <dd class="font-medium text-white"></dd>
          </div>
          <div class="flex items-center justify-between gap-3">
            <dt class="text-slate-400">Tags</dt>
            <dd class="font-medium text-white"></dd>
          </div>
          <div class="flex items-center justify-between gap-3">
            <dt class="text-slate-400">Last Slot</dt>
            <dd class="font-medium text-white"></dd>
          </div>
          <div class="flex items-center justify-between gap-3">
            <dt class="text-slate-400">Slot Lag</dt>
            <dd class="font-medium text-white"></dd>
          </div>
          <div class="flex items-center justify-between gap-3">
            <dt class="text-slate-400">Last Seen</dt>
            <dd class="font-medium text-white"></dd>
          </div>
        </dl>
        <div class="mt-6 flex items-center justify-between text-xs text-slate-400">
          <span class="inline-flex items-center gap-2 rounded-full bg-white/5 px-3 py-1 font-medium text-white/80"></span>
          <span class="uppercase tracking-[0.3em]"></span>
        </div>
        <div class="pointer-events-none absolute inset-x-0 bottom-0 h-24 bg-gradient-to-t from-white/10 to-transparent opacity-0 transition duration-300 group-hover:opacity-100"></div>
      </article>
    </template>

    <script>
      /**
       * @typedef {Object} DashboardProvider
       * @property {string} name
       * @property {number|null} latency
       * @property {number} latency_ema
       * @property {number} success
       * @property {number} errors
       * @property {number} probe_success
       * @property {number} probe_errors
       * @property {boolean} healthy
       * @property {number|null} last_slot
       * @property {number|null} slots_behind
       * @property {number} weight
       * @property {number} effective_weight
       * @property {number} tag_multiplier
       * @property {string[]} tags
       * @property {number} score
       * @property {boolean} quarantined
       * @property {number|null} quarantined_until_ms
       * @property {number} last_updated_ms
       */

      /**
       * @typedef {Object} DashboardSnapshot
       * @property {DashboardProvider[]} providers
       * @property {number} updated_at
       * @property {number|null} best_slot
       */

      // Constants
      const AUTO_REFRESH_INTERVAL_MS = 5000;
      const COUNTDOWN_UPDATE_INTERVAL_MS = 1000;
      const MAX_RETRY_ATTEMPTS = 3;
      const RETRY_DELAY_MS = 1000;
      const SLOT_LAG_STALE_THRESHOLD = 64;
      const SLOT_LAG_WATCH_THRESHOLD = 16;
      const SCORE_PREFERRED_THRESHOLD = 120;
      const SCORE_BALANCED_THRESHOLD = 200;
      const METRICS_ENDPOINT = "/metrics.json";

      // DOM References
      const providerCardsContainer = document.getElementById("providerCards");
      const providerCardTemplate = document.getElementById("providerCardTemplate");
      const providerCountEl = document.getElementById("providerCount");
      const healthyCountEl = document.getElementById("healthyCount");
      const avgLatencyEl = document.getElementById("avgLatency");
      const latencyDetailEl = document.getElementById("latencyDetail");
      const lastUpdatedEl = document.getElementById("lastUpdated");
      const updatedAgoEl = document.getElementById("updatedAgo");
      const refreshButton = document.getElementById("refreshButton");
      const autoRefreshToggle = document.getElementById("autoRefreshToggle");
      const autoRefreshStatusEl = document.getElementById("autoRefreshStatus");
      const errorBanner = document.getElementById("errorBanner");
      const metricToggle = document.getElementById("metricToggle");
      const metricButtons = Array.from(metricToggle.querySelectorAll(".metric-toggle"));

      // State
      let latencyChart = null;
      let currentMetric = "latency";
      let lastSnapshot = null;
      let autoRefreshEnabled = autoRefreshToggle.checked;
      let autoRefreshTimeoutId = null;
      let autoRefreshCountdownId = null;
      let nextRefreshAt = null;
      let isOnline = navigator.onLine;
      let retryCount = 0;

      /**
       * Sets the active metric and updates UI accordingly
       * @param {string} metric - The metric to activate ('latency' | 'latency_ema' | 'score')
       */
      function setActiveMetric(metric) {
        currentMetric = metric;
        metricButtons.forEach((button) => {
          const isActive = button.dataset.metric === metric;
          button.setAttribute("aria-pressed", isActive.toString());
          button.classList.toggle("bg-aurora", isActive);
          button.classList.toggle("text-white", isActive);
          button.classList.toggle("shadow-lg", isActive);
          button.classList.toggle("shadow-aurora/30", isActive);
          button.classList.toggle("shadow-none", !isActive);
          button.classList.toggle("bg-transparent", !isActive);
          button.classList.toggle("text-slate-300", !isActive);
        });
        if (lastSnapshot) {
          renderChart(lastSnapshot, currentMetric);
        }
      }

      // Event delegation for metric buttons
      metricToggle.addEventListener("click", (e) => {
        const button = e.target.closest(".metric-toggle");
        if (button && button.dataset.metric) {
          setActiveMetric(button.dataset.metric);
        }
      });

      // Initialize metric button accessibility
      metricButtons.forEach((button) => {
        button.setAttribute("role", "button");
        button.setAttribute("aria-pressed", "false");
      });

      /**
       * Formats a millisecond value for display
       * @param {number|null|undefined} value - The value in milliseconds
       * @returns {string} Formatted string or "n/a"
       */
      function formatMillis(value) {
        if (value == null || Number.isNaN(value)) {
          return "n/a";
        }
        return `${value.toFixed(1)} ms`;
      }

      /**
       * Formats a score value for display
       * @param {number} value - The score value
       * @returns {string} Formatted score or em dash
       */
      function formatScore(value) {
        return Number.isFinite(value) ? value.toFixed(2) : "—";
      }

      function formatEffectiveWeight(base, multiplier, effective) {
        const safeBase = Number(base) || 1;
        const safeMultiplier = Number(multiplier) || 1;
        const safeEffective = Number.isFinite(effective) ? effective : safeBase * safeMultiplier;
        const roundedEffective = safeEffective.toFixed(2);
        if (Math.abs(safeMultiplier - 1) < 1e-6) {
          return `${roundedEffective} (base ${safeBase})`;
        }
        return `${roundedEffective} (base ${safeBase} × ${safeMultiplier.toFixed(2)})`;
      }

      function formatCount(value) {
        if (typeof value !== "number" || Number.isNaN(value)) {
          return "0";
        }
        return value.toLocaleString("en-US");
      }

      function formatPercent(value) {
        if (!Number.isFinite(value)) {
          return "0";
        }
        const fixed = value.toFixed(1);
        return fixed.endsWith(".0") ? fixed.slice(0, -2) : fixed;
      }

      function formatRequestCounts(success = 0, errors = 0) {
        const ok = Number(success) || 0;
        const fail = Number(errors) || 0;
        const total = ok + fail;
        if (total === 0) {
          return "0 / 0 (no traffic)";
        }
        const rate = (ok / total) * 100;
        return `${formatCount(ok)} / ${formatCount(fail)} (${formatPercent(rate)}% ok)`;
      }

      function formatProbeCounts(passes = 0, fails = 0) {
        const ok = Number(passes) || 0;
        const fail = Number(fails) || 0;
        const total = ok + fail;
        if (total === 0) {
          return "0 / 0 (no probes)";
        }
        const rate = (ok / total) * 100;
        return `${formatCount(ok)} / ${formatCount(fail)} (${formatPercent(rate)}% pass)`;
      }

      function formatTimestamp(ms) {
        if (!ms) return "—";
        return new Date(ms).toLocaleTimeString();
      }

      /**
       * Formats relative time from a timestamp
       * @param {number|null} ms - Timestamp in milliseconds
       * @returns {string} Relative time string
       */
      function relativeTimeFrom(ms) {
        if (!ms) return "Awaiting data";
        const delta = Date.now() - ms;
        if (delta < 0) return "Just now";
        const seconds = Math.floor(delta / 1000);
        if (seconds <= 0) return "Just now";
        if (seconds < 60) return `${seconds}s ago`;
        const minutes = Math.floor(seconds / 60);
        if (minutes < 60) return `${minutes}m ago`;
        const hours = Math.floor(minutes / 60);
        return `${hours}h ago`;
      }

      /**
       * Formats relative time until a timestamp
       * @param {number|null} ms - Future timestamp in milliseconds
       * @returns {string} Relative time string
       */
      function relativeTimeUntil(ms) {
        if (!ms) return "";
        const delta = ms - Date.now();
        if (delta <= 0) return "ready";
        const seconds = Math.floor(delta / 1000);
        if (seconds < 60) return `${seconds}s`;
        const minutes = Math.floor(seconds / 60);
        if (minutes < 60) return `${minutes}m`;
        const hours = Math.floor(minutes / 60);
        return `${hours}h`;
      }

      /**
       * Formats slot lag for display
       * @param {number|null} lag - Number of slots behind
       * @returns {string} Formatted lag string
       */
      function formatSlotLag(lag) {
        if (lag == null) return "--";
        if (lag === 0) return "In sync";
        if (lag === 1) return "1 slot";
        return `${lag} slots`;
      }

      /**
       * Displays an error message in the banner
       * @param {string} message - Error message to display
       */
      function showError(message) {
        if (!message) return;
        errorBanner.textContent = message;
        errorBanner.classList.remove("hidden");
        errorBanner.setAttribute("aria-live", "assertive");
      }

      /**
       * Clears the error banner
       */
      function clearError() {
        if (!errorBanner.classList.contains("hidden")) {
          errorBanner.classList.add("hidden");
        }
        errorBanner.textContent = "";
        errorBanner.removeAttribute("aria-live");
      }

      /**
       * Clears all auto-refresh timers
       */
      function clearAutoRefreshTimers() {
        if (autoRefreshTimeoutId != null) {
          clearTimeout(autoRefreshTimeoutId);
          autoRefreshTimeoutId = null;
        }
        if (autoRefreshCountdownId != null) {
          clearInterval(autoRefreshCountdownId);
          autoRefreshCountdownId = null;
        }
      }

      /**
       * Updates the auto-refresh status display
       * @param {string|null} overrideText - Optional override text
       */
      function updateAutoRefreshStatus(overrideText) {
        if (overrideText) {
          autoRefreshStatusEl.textContent = overrideText;
          return;
        }
        if (!autoRefreshEnabled) {
          autoRefreshStatusEl.textContent = "Paused";
          return;
        }
        if (refreshButton.disabled) {
          autoRefreshStatusEl.textContent = "Refreshing...";
          return;
        }
        if (!isOnline) {
          autoRefreshStatusEl.textContent = "Offline";
          return;
        }
        if (!nextRefreshAt) {
          autoRefreshStatusEl.textContent = "Waiting...";
          return;
        }
        const remainingMs = nextRefreshAt - Date.now();
        if (remainingMs <= 0) {
          autoRefreshStatusEl.textContent = "Now";
          return;
        }
        const seconds = Math.ceil(remainingMs / 1000);
        autoRefreshStatusEl.textContent = `Next in ${seconds}s`;
      }

      /**
       * Queues the next auto-refresh
       */
      function queueAutoRefresh() {
        clearAutoRefreshTimers();
        if (!autoRefreshEnabled || !isOnline) {
          nextRefreshAt = null;
          updateAutoRefreshStatus();
          return;
        }
        nextRefreshAt = Date.now() + AUTO_REFRESH_INTERVAL_MS;
        updateAutoRefreshStatus();
        autoRefreshCountdownId = setInterval(() => {
          updateAutoRefreshStatus();
        }, COUNTDOWN_UPDATE_INTERVAL_MS);
        autoRefreshTimeoutId = setTimeout(() => {
          if (!autoRefreshEnabled || !isOnline) {
            return;
          }
          if (refreshButton.disabled) {
            queueAutoRefresh();
            return;
          }
          refresh().finally(() => {
            if (autoRefreshEnabled && isOnline) {
              queueAutoRefresh();
            } else {
              updateAutoRefreshStatus();
            }
          });
        }, AUTO_REFRESH_INTERVAL_MS);
      }

      /**
       * Updates the statistics display with snapshot data
       * @param {DashboardSnapshot} snapshot - The dashboard snapshot
       */
      function updateStats(snapshot) {
        const providers = snapshot.providers;
        const healthy = providers.filter((p) => p.healthy);
        const standby = providers.filter((p) => !p.healthy && !p.quarantined);
        const quarantined = providers.filter((p) => p.quarantined);
        
        providerCountEl.textContent = providers.length.toString();
        healthyCountEl.textContent = `${healthy.length} active, ${standby.length} standby, ${quarantined.length} quarantined`;

        const measured = providers.filter((p) => Number.isFinite(p.latency ?? p.latency_ema));
        const avgLatency =
          measured.length > 0
            ? measured.reduce((sum, p) => sum + (p.latency ?? p.latency_ema ?? 0), 0) / measured.length
            : 0;
        avgLatencyEl.textContent = measured.length ? `${avgLatency.toFixed(1)} ms` : "n/a";
        
        const bestSlot =
          typeof snapshot.best_slot === "number" && snapshot.best_slot > 0 ? snapshot.best_slot : null;
        
        // Calculate totals using a single pass
        const totals = providers.reduce(
          (acc, p) => {
            acc.requestSuccess += Number(p.success) || 0;
            acc.requestErrors += Number(p.errors) || 0;
            acc.probeSuccess += Number(p.probe_success) || 0;
            acc.probeErrors += Number(p.probe_errors) || 0;
            return acc;
          },
          { requestSuccess: 0, requestErrors: 0, probeSuccess: 0, probeErrors: 0 }
        );
        
        const requestTotal = totals.requestSuccess + totals.requestErrors;
        const trafficSummary =
          requestTotal > 0
            ? `traffic ${formatCount(totals.requestSuccess)} / ${formatCount(totals.requestErrors)} (${formatPercent(
                (totals.requestSuccess / requestTotal) * 100
              )}% ok)`
            : "traffic idle";
        
        const probeTotal = totals.probeSuccess + totals.probeErrors;
        const probeSummary =
          probeTotal > 0
            ? `probes ${formatCount(totals.probeSuccess)} / ${formatCount(totals.probeErrors)} (${formatPercent(
                (totals.probeSuccess / probeTotal) * 100
              )}% pass)`
            : "probes idle";
        
        const slotText = bestSlot != null ? `latest slot ${bestSlot}` : "awaiting slot data";
        latencyDetailEl.textContent = measured.length
          ? `Across ${measured.length} providers reporting | ${slotText} | ${trafficSummary} | ${probeSummary}`
          : `Waiting for latency samples | ${slotText} | ${trafficSummary} | ${probeSummary}`;

        lastUpdatedEl.textContent = formatTimestamp(snapshot.updated_at);
        updatedAgoEl.textContent = relativeTimeFrom(snapshot.updated_at);
      }

      /**
       * Renders or updates the latency chart
       * @param {DashboardSnapshot} snapshot - The dashboard snapshot
       * @param {string} metricKey - The metric to display
       */
      function renderChart(snapshot, metricKey = currentMetric) {
        const providers = snapshot.providers;
        
        // Single pass to compute all data
        const chartData = providers.map((p) => {
          const metricValue =
            metricKey === "latency"
              ? p.latency ?? p.latency_ema
              : metricKey === "latency_ema"
              ? p.latency_ema
              : p.score;
          
          let backgroundColor;
          if (p.quarantined) {
            backgroundColor = "rgba(248, 113, 113, 0.75)";
          } else {
            backgroundColor = p.healthy ? "rgba(99, 102, 241, 0.8)" : "rgba(249, 115, 22, 0.6)";
          }
          
          return {
            label: p.name,
            value: Number.isFinite(metricValue) ? metricValue : 0,
            color: backgroundColor,
          };
        });

        const labels = chartData.map((d) => d.label);
        const values = chartData.map((d) => d.value);
        const backgroundColors = chartData.map((d) => d.color);

        const datasetLabel =
          metricKey === "score"
            ? "Weighted Score (lower is better)"
            : metricKey === "latency_ema"
            ? "Latency EMA (ms)"
            : "Live Latency (ms)";

        if (!latencyChart) {
          const ctx = document.getElementById("latencyChart").getContext("2d");
          latencyChart = new Chart(ctx, {
            type: "bar",
            data: {
              labels,
              datasets: [
                {
                  label: datasetLabel,
                  data: values,
                  backgroundColor: backgroundColors,
                  borderRadius: 10,
                },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              animation: {
                duration: 300,
              },
              transitions: {
                active: {
                  animation: {
                    duration: 0,
                  },
                },
              },
              scales: {
                x: {
                  ticks: {
                    color: "rgba(226,232,240,0.85)",
                    maxRotation: 45,
                    minRotation: 45,
                  },
                  grid: {
                    display: false,
                  },
                },
                y: {
                  ticks: {
                    color: "rgba(148,163,184,0.8)",
                  },
                  grid: {
                    color: "rgba(15,23,42,0.4)",
                  },
                  beginAtZero: true,
                },
              },
              plugins: {
                legend: {
                  labels: {
                    color: "rgba(226,232,240,0.85)",
                  },
                },
                tooltip: {
                  backgroundColor: "rgba(15, 23, 42, 0.95)",
                  titleColor: "rgba(226, 232, 240, 1)",
                  bodyColor: "rgba(226, 232, 240, 0.9)",
                  borderColor: "rgba(99, 102, 241, 0.5)",
                  borderWidth: 1,
                },
              },
            },
          });
        } else {
          // Update chart data efficiently
          latencyChart.data.labels = labels;
          latencyChart.data.datasets[0].data = values;
          latencyChart.data.datasets[0].label = datasetLabel;
          latencyChart.data.datasets[0].backgroundColor = backgroundColors;
          // Use 'none' mode for faster updates during auto-refresh
          latencyChart.update("none");
        }
      }

      /**
       * Renders provider cards using DocumentFragment for better performance
       * @param {DashboardSnapshot} snapshot - The dashboard snapshot
       */
      function renderProviders(snapshot) {
        // Use DocumentFragment to batch DOM operations
        const fragment = document.createDocumentFragment();
        
        snapshot.providers.forEach((provider) => {
          const card = providerCardTemplate.content.cloneNode(true);
          const [nameEl, subtitleEl] = card.querySelectorAll("h3, p");
          nameEl.textContent = provider.name;
          nameEl.setAttribute("id", `provider-${provider.name.replace(/\s+/g, "-").toLowerCase()}`);

          const slotsBehind = provider.slots_behind ?? null;
          let relativeScore;
          if (provider.quarantined) {
            relativeScore = "Quarantined (cooldown)";
          } else if (slotsBehind != null && slotsBehind >= SLOT_LAG_STALE_THRESHOLD) {
            relativeScore = "Stale commitment";
          } else if (slotsBehind != null && slotsBehind >= SLOT_LAG_WATCH_THRESHOLD) {
            relativeScore = "Watch commitment";
          } else if (provider.score <= SCORE_PREFERRED_THRESHOLD) {
            relativeScore = "Preferred route";
          } else if (provider.score <= SCORE_BALANCED_THRESHOLD) {
            relativeScore = "Balanced candidate";
          } else {
            relativeScore = "Warm standby";
          }
          
          const tagList = Array.isArray(provider.tags) && provider.tags.length
            ? provider.tags.join(", ")
            : "";
          subtitleEl.textContent = tagList ? `${relativeScore} • ${tagList}` : relativeScore;

          const statusBadge = card.querySelector("span.flex.items-center");
          const badgeDot = statusBadge.querySelector("span");
          const badgeLabel = statusBadge.querySelectorAll("span")[1];

          statusBadge.classList.add("px-3", "py-1", "rounded-full", "transition-colors", "duration-300");
          statusBadge.setAttribute("aria-label", `Status: ${provider.quarantined ? "Quarantined" : provider.healthy ? "Healthy" : "Degraded"}`);

          if (provider.quarantined) {
            badgeLabel.textContent = "Quarantined";
            statusBadge.classList.add("bg-red-500/20", "text-red-300");
            badgeDot.classList.add("bg-red-400");
          } else if (provider.healthy) {
            badgeLabel.textContent = "Healthy";
            statusBadge.classList.add("bg-success/15", "text-success");
            badgeDot.classList.add("bg-success");
          } else {
            badgeLabel.textContent = "Degraded";
            statusBadge.classList.add("bg-warning/20", "text-warning");
            badgeDot.classList.add("bg-warning");
          }

          const details = card.querySelectorAll("dd");
          details[0].textContent = formatMillis(provider.latency ?? provider.latency_ema);
          details[1].textContent = formatMillis(provider.latency_ema);
          details[2].textContent = formatRequestCounts(provider.success, provider.errors);
          details[3].textContent = formatProbeCounts(provider.probe_success, provider.probe_errors);
          details[4].textContent = formatScore(provider.score);
          details[5].textContent = formatEffectiveWeight(
            provider.weight,
            provider.tag_multiplier ?? 1,
            provider.effective_weight ?? provider.weight
          );
          details[6].textContent = tagList || "—";
          details[7].textContent = provider.last_slot ?? "--";
          details[8].textContent = formatSlotLag(slotsBehind);
          details[9].textContent = relativeTimeFrom(provider.last_updated_ms);

          const footerSpans = card.querySelectorAll(".mt-6 span");
          const multiplierText =
            provider.tag_multiplier && Math.abs(provider.tag_multiplier - 1) > 1e-6
              ? `Weight ${provider.weight} × ${provider.tag_multiplier.toFixed(2)}`
              : `Weight ${provider.weight}`;
          footerSpans[0].textContent = multiplierText;
          
          if (provider.quarantined) {
            const releaseWindow = relativeTimeUntil(provider.quarantined_until_ms);
            footerSpans[1].textContent = releaseWindow
              ? `QUARANTINED (release in ${releaseWindow})`
              : "QUARANTINED";
          } else {
            footerSpans[1].textContent = provider.healthy ? "ACTIVE" : "STANDBY";
          }

          fragment.appendChild(card);
        });

        // Single DOM update for all cards
        providerCardsContainer.innerHTML = "";
        providerCardsContainer.appendChild(fragment);
      }

      /**
       * Fetches the metrics snapshot with retry logic
       * @param {number} attempt - Current retry attempt (default: 0)
       * @returns {Promise<DashboardSnapshot>} The dashboard snapshot
       */
      async function fetchSnapshot(attempt = 0) {
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 10000); // 10s timeout
          
          const res = await fetch(METRICS_ENDPOINT, {
            headers: {
              "cache-control": "no-cache",
            },
            signal: controller.signal,
          });
          
          clearTimeout(timeoutId);
          
          if (!res.ok) {
            throw new Error(`HTTP ${res.status}: ${res.statusText || "Failed to load metrics"}`);
          }
          
          const data = await res.json();
          retryCount = 0; // Reset on success
          return data;
        } catch (err) {
          if (attempt < MAX_RETRY_ATTEMPTS && (err.name === "NetworkError" || err.name === "AbortError" || err.message.includes("HTTP"))) {
            const delay = RETRY_DELAY_MS * Math.pow(2, attempt); // Exponential backoff
            await new Promise((resolve) => setTimeout(resolve, delay));
            return fetchSnapshot(attempt + 1);
          }
          throw err;
        }
      }

      /**
       * Refreshes the dashboard data
       */
      async function refresh() {
        if (!isOnline) {
          showError("You are currently offline. Please check your internet connection.");
          updateAutoRefreshStatus("Offline");
          return;
        }

        clearError();
        refreshButton.disabled = true;
        refreshButton.classList.add("opacity-65");
        refreshButton.setAttribute("aria-busy", "true");
        updateAutoRefreshStatus("Refreshing...");

        try {
          const snapshot = await fetchSnapshot();
          lastSnapshot = snapshot;
          updateStats(snapshot);
          renderChart(snapshot, currentMetric);
          renderProviders(snapshot);
        } catch (err) {
          console.error("Failed to refresh dashboard:", err);
          const errorMessage = err instanceof Error 
            ? err.message 
            : "Failed to load metrics snapshot. Please try again.";
          showError(errorMessage);
          
          if (retryCount < MAX_RETRY_ATTEMPTS) {
            retryCount++;
          }
        } finally {
          refreshButton.disabled = false;
          refreshButton.classList.remove("opacity-65");
          refreshButton.removeAttribute("aria-busy");
          updateAutoRefreshStatus();
        }
      }

      // Event handlers
      refreshButton.addEventListener("click", () => {
        clearAutoRefreshTimers();
        refresh().finally(() => {
          if (autoRefreshEnabled && isOnline) {
            queueAutoRefresh();
          } else {
            updateAutoRefreshStatus();
          }
        });
      });

      // Keyboard support for refresh button
      refreshButton.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          refreshButton.click();
        }
      });

      autoRefreshToggle.addEventListener("change", () => {
        autoRefreshEnabled = autoRefreshToggle.checked;
        if (autoRefreshEnabled && isOnline) {
          queueAutoRefresh();
        } else {
          clearAutoRefreshTimers();
          nextRefreshAt = null;
          updateAutoRefreshStatus();
        }
      });

      // Online/offline event handlers
      window.addEventListener("online", () => {
        isOnline = true;
        clearError();
        updateAutoRefreshStatus();
        if (autoRefreshEnabled) {
          refresh().finally(() => {
            if (autoRefreshEnabled) {
              queueAutoRefresh();
            }
          });
        }
      });

      window.addEventListener("offline", () => {
        isOnline = false;
        clearAutoRefreshTimers();
        showError("Connection lost. Auto-refresh paused.");
        updateAutoRefreshStatus("Offline");
      });

      // Cleanup on page unload
      window.addEventListener("beforeunload", () => {
        clearAutoRefreshTimers();
        if (latencyChart) {
          latencyChart.destroy();
          latencyChart = null;
        }
      });

      // Handle visibility changes - pause when tab is hidden
      document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
          // Keep running but reduce frequency could be implemented here
        } else if (autoRefreshEnabled && isOnline) {
          // Resume if it was paused
          if (!autoRefreshTimeoutId) {
            queueAutoRefresh();
          }
        }
      });

      // Initialize
      setActiveMetric("latency");
      updateAutoRefreshStatus();
      
      // Initial load
      refresh().finally(() => {
        if (autoRefreshEnabled && isOnline) {
          queueAutoRefresh();
        } else {
          updateAutoRefreshStatus();
        }
      });
    </script>
  </body>
</html>
