<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Open RPC Load Balancer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              midnight: "#090d1a",
              aurora: "#6366f1",
              auroraLight: "#a855f7",
              success: "#34d399",
              warning: "#fb923c",
            },
          },
        },
      };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
  </head>
  <body class="bg-midnight text-slate-100 min-h-[100vh]">
    <div class="relative flex min-h-[100vh] flex-col overflow-hidden">
      <div
        class="pointer-events-none absolute inset-0 opacity-35"
        style="
          background:
            radial-gradient(circle at top, rgba(99, 102, 241, 0.35), transparent 60%),
            radial-gradient(circle at right, rgba(168, 85, 247, 0.28), transparent 55%),
            radial-gradient(circle at bottom left, rgba(14, 165, 233, 0.2), transparent 60%);
        "
      ></div>

      <main class="relative z-10 mx-auto flex min-h-[100vh] w-full max-w-6xl flex-col gap-10 px-6 py-12">
        <div
          id="errorBanner"
          class="hidden rounded-3xl border border-red-400/30 bg-red-500/10 px-6 py-3 text-sm text-red-200 shadow-lg shadow-red-900/30"
          role="alert"
        ></div>
        <header class="rounded-3xl border border-white/10 bg-white/5 px-8 py-10 shadow-xl shadow-aurora/5 backdrop-blur">
          <div class="flex flex-col gap-6 md:flex-row md:items-center md:justify-between">
            <div>
              <p class="text-sm uppercase tracking-[0.3em] text-slate-400">Open RPC Load Balancer</p>
              <h1 class="mt-2 text-3xl font-semibold md:text-4xl">Provider Command Console</h1>
              <p class="mt-3 max-w-xl text-sm text-slate-400">
                Inspect live RPC health, route scores, and probe history at a glance. Snapshots auto refresh every 5 seconds; tap the button any time you want an instant update.
              </p>
            </div>
            <div class="flex flex-col items-end gap-3 text-right">
              <button
                id="refreshButton"
                type="button"
                class="inline-flex items-center gap-3 rounded-full bg-aurora px-6 py-2.5 text-sm font-semibold text-white shadow-lg shadow-aurora/30 transition hover:translate-y-0.5 hover:bg-auroraLight focus:outline-none focus:ring-2 focus:ring-aurora/60"
              >
                <span class="inline-flex h-2.5 w-2.5 items-center justify-center rounded-full bg-white/80 shadow-inner shadow-white/40"></span>
                <span>Refresh snapshot</span>
              </button>
              <div class="flex items-center gap-2 text-xs text-slate-300">
                <label
                  for="autoRefreshToggle"
                  class="inline-flex items-center gap-2 rounded-full border border-white/10 bg-slate-900/70 px-3 py-1 shadow-inner shadow-black/40 transition hover:border-white/20"
                >
                  <input
                    id="autoRefreshToggle"
                    type="checkbox"
                    class="h-4 w-4 rounded border-white/30 bg-slate-900/60 text-aurora focus:ring-aurora/60"
                    checked
                  />
                  <span class="font-medium uppercase tracking-[0.2em] text-slate-400">Auto</span>
                </label>
                <span id="autoRefreshStatus" class="rounded-full border border-white/10 bg-white/10 px-2 py-1 font-medium tracking-wide text-slate-300" aria-live="polite">
                  Next in 5s
                </span>
              </div>
            </div>
          </div>

          <dl class="mt-8 grid gap-5 sm:grid-cols-3">
            <div class="rounded-2xl border border-white/10 bg-white/5 p-5 shadow-inner shadow-white/5">
              <dt class="text-xs uppercase tracking-[0.2em] text-slate-400">Providers Online</dt>
              <dd class="mt-3 text-3xl font-semibold" id="providerCount">--</dd>
              <p class="mt-1 text-xs text-slate-400" id="healthyCount">--</p>
            </div>
            <div class="rounded-2xl border border-white/10 bg-white/5 p-5 shadow-inner shadow-white/5">
              <dt class="text-xs uppercase tracking-[0.2em] text-slate-400">Average Latency</dt>
              <dd class="mt-3 text-3xl font-semibold" id="avgLatency">--</dd>
              <p class="mt-1 text-xs text-slate-400" id="latencyDetail">--</p>
            </div>
            <div class="rounded-2xl border border-white/10 bg-white/5 p-5 shadow-inner shadow-white/5">
              <dt class="text-xs uppercase tracking-[0.2em] text-slate-400">Last Updated</dt>
              <dd class="mt-3 text-3xl font-semibold" id="lastUpdated">--</dd>
              <p class="mt-1 text-xs text-slate-400" id="updatedAgo">--</p>
            </div>
          </dl>
        </header>

        <section class="rounded-3xl border border-white/10 bg-white/5 p-8 backdrop-blur">
          <div class="flex flex-col gap-4 md:flex-row md:items-center md:justify-between">
            <div>
              <h2 class="text-xl font-semibold">Latency & Scoreboard</h2>
              <p class="text-sm text-slate-400">
                Compare providers side-by-side. Lower scores indicate stronger candidates for routing while accounting for latency and previous errors.
              </p>
            </div>
            <div
              id="metricToggle"
              class="inline-flex items-center gap-1 rounded-full border border-white/15 bg-slate-900/70 p-1 text-xs font-medium text-slate-300 shadow-inner shadow-black/40"
              role="group"
            >
              <button
                type="button"
                class="metric-toggle inline-flex items-center gap-2 rounded-full px-4 py-2 text-slate-300 transition focus:outline-none focus-visible:ring-2 focus-visible:ring-aurora/60"
                data-metric="latency"
              >
                Live Latency
              </button>
              <button
                type="button"
                class="metric-toggle inline-flex items-center gap-2 rounded-full px-4 py-2 text-slate-300 transition focus:outline-none focus-visible:ring-2 focus-visible:ring-aurora/60"
                data-metric="latency_ema"
              >
                Latency EMA
              </button>
              <button
                type="button"
                class="metric-toggle inline-flex items-center gap-2 rounded-full px-4 py-2 text-slate-300 transition focus:outline-none focus-visible:ring-2 focus-visible:ring-aurora/60"
                data-metric="score"
              >
                Weighted Score
              </button>
            </div>
          </div>
          <div class="mt-6 h-72 rounded-2xl border border-white/10 bg-white/5 p-4">
            <canvas id="latencyChart"></canvas>
          </div>
        </section>

        <section class="space-y-6">
          <div>
            <h2 class="text-xl font-semibold">Provider Deep Dive</h2>
            <p class="text-sm text-slate-400">
              Hover each card to view detailed stats, weights, error streaks, and last observed slot height. Cards stay put until you refresh.
            </p>
          </div>

          <div
            id="providerCards"
            class="grid gap-6 sm:grid-cols-2 xl:grid-cols-3"
          ></div>
        </section>
      </main>
    </div>

    <template id="providerCardTemplate">
      <article class="group relative overflow-hidden rounded-3xl border border-white/10 bg-gradient-to-br from-white/10 via-white/5 to-transparent p-6 backdrop-blur transition hover:border-white/30 hover:shadow-2xl hover:shadow-aurora/10">
        <div class="flex items-start justify-between gap-3">
          <div>
            <h3 class="text-lg font-semibold"></h3>
            <p class="text-sm text-slate-400"></p>
          </div>
          <span class="flex items-center gap-2 rounded-full px-3 py-1 text-xs font-semibold">
            <span class="h-2 w-2 rounded-full"></span>
            <span></span>
          </span>
        </div>
        <dl class="mt-6 space-y-3 text-sm">
          <div class="flex items-center justify-between gap-3">
            <dt class="text-slate-400">Latency</dt>
            <dd class="font-medium"></dd>
          </div>
          <div class="flex items-center justify-between gap-3">
            <dt class="text-slate-400">EMA (ms)</dt>
            <dd class="font-medium"></dd>
          </div>
          <div class="flex items-center justify-between gap-3">
            <dt class="text-slate-400">Success / Errors</dt>
            <dd class="font-medium"></dd>
          </div>
          <div class="flex items-center justify-between gap-3">
            <dt class="text-slate-400">Weighted Score</dt>
            <dd class="font-medium"></dd>
          </div>
          <div class="flex items-center justify-between gap-3">
            <dt class="text-slate-400">Last Slot</dt>
            <dd class="font-medium"></dd>
          </div>
          <div class="flex items-center justify-between gap-3">
            <dt class="text-slate-400">Slot Lag</dt>
            <dd class="font-medium"></dd>
          </div>
          <div class="flex items-center justify-between gap-3">
            <dt class="text-slate-400">Last Seen</dt>
            <dd class="font-medium"></dd>
          </div>
        </dl>
        <div class="mt-6 flex items-center justify-between text-xs text-slate-400">
          <span class="inline-flex items-center gap-2">
            <span class="rounded-full bg-white/10 px-3 py-1 font-medium text-white/80"></span>
          </span>
          <span class="uppercase tracking-[0.2em]"></span>
        </div>
      </article>
    </template>

    <script>
      const providerCardsContainer = document.getElementById("providerCards");
      const providerCardTemplate = document.getElementById("providerCardTemplate");
      const providerCountEl = document.getElementById("providerCount");
      const healthyCountEl = document.getElementById("healthyCount");
      const avgLatencyEl = document.getElementById("avgLatency");
      const latencyDetailEl = document.getElementById("latencyDetail");
      const lastUpdatedEl = document.getElementById("lastUpdated");
      const updatedAgoEl = document.getElementById("updatedAgo");
      const refreshButton = document.getElementById("refreshButton");
      const autoRefreshToggle = document.getElementById("autoRefreshToggle");
      const autoRefreshStatusEl = document.getElementById("autoRefreshStatus");
      const errorBanner = document.getElementById("errorBanner");

      const metricToggle = document.getElementById("metricToggle");
      const metricButtons = Array.from(metricToggle.querySelectorAll(".metric-toggle"));
      const AUTO_REFRESH_INTERVAL_MS = 5000;
      let latencyChart = null;
      let currentMetric = "latency";
      let lastSnapshot = null;
      let autoRefreshEnabled = true;
      let autoRefreshTimeoutId = null;
      let autoRefreshCountdownId = null;
      let nextRefreshAt = null;
      autoRefreshEnabled = autoRefreshToggle.checked;

      function setActiveMetric(metric) {
        currentMetric = metric;
        metricButtons.forEach((button) => {
          const isActive = button.dataset.metric === metric;
          button.classList.toggle("bg-aurora", isActive);
          button.classList.toggle("text-white", isActive);
          button.classList.toggle("shadow-lg", isActive);
          button.classList.toggle("shadow-aurora/30", isActive);
          button.classList.toggle("shadow-none", !isActive);
          button.classList.toggle("bg-transparent", !isActive);
          button.classList.toggle("text-slate-300", !isActive);
        });
        if (lastSnapshot) {
          renderChart(lastSnapshot, currentMetric);
        }
      }

      metricButtons.forEach((button) => {
        button.addEventListener("click", () => {
          setActiveMetric(button.dataset.metric);
        });
      });

      function formatMillis(value) {
        if (value == null || Number.isNaN(value)) {
          return "n/a";
        }
        return `${value.toFixed(1)} ms`;
      }

      function formatScore(value) {
        return Number.isFinite(value) ? value.toFixed(2) : "—";
      }

      function formatTimestamp(ms) {
        if (!ms) return "—";
        return new Date(ms).toLocaleTimeString();
      }

      function relativeTimeFrom(ms) {
        if (!ms) return "Awaiting data";
        const delta = Date.now() - ms;
        if (delta < 0) return "Just now";
        const seconds = Math.floor(delta / 1000);
        if (seconds <= 0) return "Just now";
        if (seconds < 60) return `${seconds}s ago`;
        const minutes = Math.floor(seconds / 60);
        if (minutes < 60) return `${minutes}m ago`;
        const hours = Math.floor(minutes / 60);
        return `${hours}h ago`;
      }

      function relativeTimeUntil(ms) {
        if (!ms) return "";
        const delta = ms - Date.now();
        if (delta <= 0) return "ready";
        const seconds = Math.floor(delta / 1000);
        if (seconds < 60) return `${seconds}s`;
        const minutes = Math.floor(seconds / 60);
        if (minutes < 60) return `${minutes}m`;
        const hours = Math.floor(minutes / 60);
        return `${hours}h`;
      }

      function formatSlotLag(lag) {
        if (lag == null) return "--";
        if (lag === 0) return "In sync";
        if (lag === 1) return "1 slot";
        return `${lag} slots`;
      }

      function showError(message) {
        if (!message) return;
        errorBanner.textContent = message;
        errorBanner.classList.remove("hidden");
      }

      function clearError() {
        if (!errorBanner.classList.contains("hidden")) {
          errorBanner.classList.add("hidden");
        }
        errorBanner.textContent = "";
      }

      function clearAutoRefreshTimers() {
        if (autoRefreshTimeoutId != null) {
          clearTimeout(autoRefreshTimeoutId);
          autoRefreshTimeoutId = null;
        }
        if (autoRefreshCountdownId != null) {
          clearInterval(autoRefreshCountdownId);
          autoRefreshCountdownId = null;
        }
      }

      function updateAutoRefreshStatus(overrideText) {
        if (overrideText) {
          autoRefreshStatusEl.textContent = overrideText;
          return;
        }
        if (!autoRefreshEnabled) {
          autoRefreshStatusEl.textContent = "Paused";
          return;
        }
        if (refreshButton.disabled) {
          autoRefreshStatusEl.textContent = "Refreshing...";
          return;
        }
        if (!nextRefreshAt) {
          autoRefreshStatusEl.textContent = "Waiting...";
          return;
        }
        const remainingMs = nextRefreshAt - Date.now();
        if (remainingMs <= 0) {
          autoRefreshStatusEl.textContent = "Now";
          return;
        }
        const seconds = Math.ceil(remainingMs / 1000);
        autoRefreshStatusEl.textContent = `Next in ${seconds}s`;
      }

      function queueAutoRefresh() {
        clearAutoRefreshTimers();
        if (!autoRefreshEnabled) {
          nextRefreshAt = null;
          updateAutoRefreshStatus();
          return;
        }
        nextRefreshAt = Date.now() + AUTO_REFRESH_INTERVAL_MS;
        updateAutoRefreshStatus();
        autoRefreshCountdownId = setInterval(() => {
          updateAutoRefreshStatus();
        }, 1000);
        autoRefreshTimeoutId = setTimeout(() => {
          if (!autoRefreshEnabled) {
            return;
          }
          if (refreshButton.disabled) {
            queueAutoRefresh();
            return;
          }
          refresh().finally(() => {
            if (autoRefreshEnabled) {
              queueAutoRefresh();
            } else {
              updateAutoRefreshStatus();
            }
          });
        }, AUTO_REFRESH_INTERVAL_MS);
      }

      function updateStats(snapshot) {
        const providers = snapshot.providers;
        const healthy = providers.filter((p) => p.healthy);
        const standby = providers.filter((p) => !p.healthy && !p.quarantined);
        const quarantined = providers.filter((p) => p.quarantined);
        providerCountEl.textContent = providers.length.toString();
        healthyCountEl.textContent = `${healthy.length} active, ${standby.length} standby, ${quarantined.length} quarantined`;

        const measured = providers.filter((p) => Number.isFinite(p.latency ?? p.latency_ema));
        const avgLatency =
          measured.reduce((sum, p) => sum + (p.latency ?? p.latency_ema ?? 0), 0) /
          (measured.length || 1);
        avgLatencyEl.textContent = measured.length ? `${avgLatency.toFixed(1)} ms` : "n/a";
        const bestSlot =
          typeof snapshot.best_slot === "number" && snapshot.best_slot > 0 ? snapshot.best_slot : null;
        if (measured.length) {
          const slotText = bestSlot != null ? `latest slot ${bestSlot}` : "awaiting slot data";
          latencyDetailEl.textContent = `Across ${measured.length} providers reporting; ${slotText}`;
        } else {
          latencyDetailEl.textContent = "Waiting for probe data";
        }

        lastUpdatedEl.textContent = formatTimestamp(snapshot.updated_at);
        updatedAgoEl.textContent = relativeTimeFrom(snapshot.updated_at);
      }

      function renderChart(snapshot, metricKey = currentMetric) {
        const providers = snapshot.providers;
        const labels = providers.map((p) => p.name);
        const values = providers.map((p) => {
          const metricValue =
            metricKey === "latency"
              ? p.latency ?? p.latency_ema
              : metricKey === "latency_ema"
              ? p.latency_ema
              : p.score;
          return Number.isFinite(metricValue) ? metricValue : 0;
        });

        const backgroundColors = providers.map((p) => {
          if (p.quarantined) {
            return "rgba(248, 113, 113, 0.75)";
          }
          return p.healthy ? "rgba(99, 102, 241, 0.8)" : "rgba(249, 115, 22, 0.6)";
        });

        const datasetLabel =
          metricKey === "score"
            ? "Weighted Score (lower is better)"
            : metricKey === "latency_ema"
            ? "Latency EMA (ms)"
            : "Live Latency (ms)";

        if (!latencyChart) {
          const ctx = document.getElementById("latencyChart").getContext("2d");
          latencyChart = new Chart(ctx, {
            type: "bar",
            data: {
              labels,
              datasets: [
                {
                  label: datasetLabel,
                  data: values,
                  backgroundColor: backgroundColors,
                  borderRadius: 10,
                },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                x: {
                  ticks: {
                    color: "rgba(226,232,240,0.85)",
                  },
                  grid: {
                    display: false,
                  },
                },
                y: {
                  ticks: {
                    color: "rgba(148,163,184,0.8)",
                  },
                  grid: {
                    color: "rgba(15,23,42,0.4)",
                  },
                  beginAtZero: true,
                },
              },
              plugins: {
                legend: {
                  labels: {
                    color: "rgba(226,232,240,0.85)",
                  },
                },
              },
            },
          });
        } else {
          latencyChart.data.labels = labels;
          latencyChart.data.datasets[0].data = values;
          latencyChart.data.datasets[0].label = datasetLabel;
          latencyChart.data.datasets[0].backgroundColor = backgroundColors;
          latencyChart.update();
        }
      }

      function renderProviders(snapshot) {
        providerCardsContainer.innerHTML = "";

        snapshot.providers.forEach((provider) => {
          const card = providerCardTemplate.content.cloneNode(true);
          const [nameEl, subtitleEl] = card.querySelectorAll("h3, p");
          nameEl.textContent = provider.name;

          const slotsBehind = provider.slots_behind ?? null;
          let relativeScore;
          if (provider.quarantined) {
            relativeScore = "Quarantined (cooldown)";
          } else if (slotsBehind != null && slotsBehind >= 64) {
            relativeScore = "Stale commitment";
          } else if (slotsBehind != null && slotsBehind >= 16) {
            relativeScore = "Watch commitment";
          } else if (provider.score <= 120) {
            relativeScore = "Preferred route";
          } else if (provider.score <= 200) {
            relativeScore = "Balanced candidate";
          } else {
            relativeScore = "Warm standby";
          }
          subtitleEl.textContent = relativeScore;

          const statusBadge = card.querySelector("span.flex.items-center");
          const badgeDot = statusBadge.querySelector("span");
          const badgeLabel = statusBadge.querySelectorAll("span")[1];

          statusBadge.classList.add("px-3", "py-1", "rounded-full", "transition-colors", "duration-300");

          if (provider.quarantined) {
            badgeLabel.textContent = "Quarantined";
            statusBadge.classList.add("bg-red-500/20", "text-red-300");
            badgeDot.classList.add("bg-red-400");
          } else if (provider.healthy) {
            badgeLabel.textContent = "Healthy";
            statusBadge.classList.add("bg-success/15", "text-success");
            badgeDot.classList.add("bg-success");
          } else {
            badgeLabel.textContent = "Degraded";
            statusBadge.classList.add("bg-warning/20", "text-warning");
            badgeDot.classList.add("bg-warning");
          }

          const details = card.querySelectorAll("dd");
          details[0].textContent = formatMillis(provider.latency ?? provider.latency_ema);
          details[1].textContent = formatMillis(provider.latency_ema);
          details[2].textContent = `${provider.success} / ${provider.errors}`;
          details[3].textContent = formatScore(provider.score);
          details[4].textContent = provider.last_slot ?? "--";
          details[5].textContent = formatSlotLag(slotsBehind);
          details[6].textContent = relativeTimeFrom(provider.last_updated_ms);

          const footerSpans = card.querySelectorAll(".mt-6 span");
          footerSpans[0].textContent = `Weight ${provider.weight}`;
          if (provider.quarantined) {
            const releaseWindow = relativeTimeUntil(provider.quarantined_until_ms);
            footerSpans[1].textContent = releaseWindow
              ? `QUARANTINED (release in ${releaseWindow})`
              : "QUARANTINED";
          } else {
            footerSpans[1].textContent = provider.healthy ? "ACTIVE" : "STANDBY";
          }

          providerCardsContainer.appendChild(card);
        });
      }

      async function fetchSnapshot() {
        const res = await fetch("/metrics.json", {
          headers: {
            "cache-control": "no-cache",
          },
        });
        if (!res.ok) {
          throw new Error(`Failed to load metrics: ${res.status}`);
        }
        return res.json();
      }

      async function refresh() {
        clearError();
        refreshButton.disabled = true;
        refreshButton.classList.add("opacity-65");
        updateAutoRefreshStatus("Refreshing...");

        try {
          const snapshot = await fetchSnapshot();
          lastSnapshot = snapshot;
          updateStats(snapshot);
          renderChart(snapshot, currentMetric);
          renderProviders(snapshot);
        } catch (err) {
          console.error(err);
          showError(err instanceof Error ? err.message : "Failed to load metrics snapshot.");
        } finally {
          refreshButton.disabled = false;
          refreshButton.classList.remove("opacity-65");
          updateAutoRefreshStatus();
        }
      }

      refreshButton.addEventListener("click", () => {
        clearAutoRefreshTimers();
        refresh().finally(() => {
          if (autoRefreshEnabled) {
            queueAutoRefresh();
          } else {
            updateAutoRefreshStatus();
          }
        });
      });

      autoRefreshToggle.addEventListener("change", () => {
        autoRefreshEnabled = autoRefreshToggle.checked;
        if (autoRefreshEnabled) {
          queueAutoRefresh();
        } else {
          clearAutoRefreshTimers();
          nextRefreshAt = null;
          updateAutoRefreshStatus();
        }
      });

      // Initialize defaults
      setActiveMetric("latency");
      updateAutoRefreshStatus();
      refresh().finally(() => {
        if (autoRefreshEnabled) {
          queueAutoRefresh();
        } else {
          updateAutoRefreshStatus();
        }
      });
    </script>
  </body>
</html>
